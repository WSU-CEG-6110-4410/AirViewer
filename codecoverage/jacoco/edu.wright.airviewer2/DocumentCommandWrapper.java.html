<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DocumentCommandWrapper.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">AirViewer2</a> &gt; <a href="index.source.html" class="el_package">edu.wright.airviewer2</a> &gt; <span class="el_source">DocumentCommandWrapper.java</span></div><h1>DocumentCommandWrapper.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package edu.wright.airviewer2;

import java.io.File;
import java.io.IOException;
import static java.lang.Float.parseFloat;
import java.util.ArrayList;
import java.util.List;
import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.pdmodel.PDPage;
import org.apache.pdfbox.pdmodel.common.PDRectangle;
import org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import org.apache.pdfbox.text.PDFTextStripper;
import static java.lang.Integer.parseInt;
import java.lang.System.Logger;
import java.lang.System.Logger.Level;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 *
 * @author erik
 */
<span class="pc bpc" id="L42" title="1 of 2 branches missed.">public class DocumentCommandWrapper extends AbstractDocumentCommandWrapper {</span>

    /**
     *
     */
    private String path;

    /**
     *
     * @param aDocument
     * @param aPath
     */
    public DocumentCommandWrapper(PDDocument aDocument, String aPath) {
<span class="fc" id="L55">        super(aDocument);</span>

<span class="pc bpc" id="L57" title="2 of 4 branches missed.">        assert null != aPath;</span>
<span class="fc" id="L58">        path = aPath;</span>

<span class="fc" id="L60">        AbstractDocumentCommandWrapper.registerCommandClassWithName(new makeCommand() {</span>
            @Override
            public AbstractDocumentCommand make(AbstractDocumentCommandWrapper owner, ArrayList&lt;String&gt; args) {
<span class="nc" id="L63">                return new SaveDocumentCommand(owner, args);</span>
            }
        }, &quot;Save&quot;);
<span class="fc" id="L66">        AbstractDocumentCommandWrapper.registerCommandClassWithName(new makeCommand() {</span>
            @Override
            public AbstractDocumentCommand make(AbstractDocumentCommandWrapper owner, ArrayList&lt;String&gt; args) {
<span class="nc" id="L69">                return new SaveTextDocumentCommand(owner, args);</span>
            }
        }, &quot;SaveText&quot;);
<span class="fc" id="L72">        AbstractDocumentCommandWrapper.registerCommandClassWithName(new makeCommand() {</span>
            @Override
            public AbstractDocumentCommand make(AbstractDocumentCommandWrapper owner, ArrayList&lt;String&gt; args) {
<span class="nc" id="L75">                return new AddBoxAnnotationDocumentCommand(owner, args);</span>
            }
        }, &quot;AddBoxAnnotation&quot;);
<span class="fc" id="L78">        AbstractDocumentCommandWrapper.registerCommandClassWithName(new makeCommand() {</span>
            @Override
            public AbstractDocumentCommand make(AbstractDocumentCommandWrapper owner, ArrayList&lt;String&gt; args) {
<span class="nc" id="L81">                return new AddCircleAnnotationDocumentCommand(owner, args);</span>
            }
        }, &quot;AddCircleAnnotation&quot;);
<span class="fc" id="L84">        AbstractDocumentCommandWrapper.registerCommandClassWithName(new makeCommand() {</span>
            @Override
            public AbstractDocumentCommand make(AbstractDocumentCommandWrapper owner, ArrayList&lt;String&gt; args) {
<span class="nc" id="L87">                return new AddTextAnnotationDocumentCommand(owner, args);</span>
            }
        }, &quot;AddTextAnnotation&quot;);
<span class="fc" id="L90">        AbstractDocumentCommandWrapper.registerCommandClassWithName(new makeCommand() {</span>
            @Override
            public AbstractDocumentCommand make(AbstractDocumentCommandWrapper owner, ArrayList&lt;String&gt; args) {
<span class="nc" id="L93">                return new MoveAnnotationDocumentCommand(owner, args);</span>
            }
        }, &quot;MoveAnnotation&quot;);
<span class="fc" id="L96">        AbstractDocumentCommandWrapper.registerCommandClassWithName(new makeCommand() {</span>
            @Override
            public AbstractDocumentCommand make(AbstractDocumentCommandWrapper owner, ArrayList&lt;String&gt; args) {
<span class="nc" id="L99">                return new DeleteAnnotationDocumentCommand(owner, args);</span>
            }
        }, &quot;DeleteAnnotation&quot;);
<span class="fc" id="L102">        AbstractDocumentCommandWrapper.registerCommandClassWithName(new makeCommand() {</span>
            @Override
            public AbstractDocumentCommand make(AbstractDocumentCommandWrapper owner, ArrayList&lt;String&gt; args) {
<span class="nc" id="L105">                return new DeleteSelectedAnnotationDocumentCommand(owner, args);</span>
            }
        }, &quot;DeleteSelectedAnnotation&quot;);
<span class="fc" id="L108">    }</span>

    /**
     * Reads information from the valid PDF file if any at aPath and returns a
     * DocumentCommandWrapper instance ready to add or delete annotations to the
     * loaded information. Trace: REQ-041000, REQ-041060
     *
     * @param aPath A valid file system path to a valid PDF document.
     * @return An instance of DocumentCommandWrapper configured to apply
     * Commands to the document at aPath.
     * @throws IOException
     */
    /*@   requires aPath is valid 
      @   assignable \nothing;
      @   ensures wrappedDocument.nonAnnotationContent == \old(&lt;wrappedDocument&gt;).nonAnnotationContent
      @   ensures wrappedDocument.annotationContent ==  \old(&lt;wrappedDocument&gt;).annotationContent
      @   ensures [file at path].nonAnnotationContent == \old(&lt;[file at path]&gt;).nonAnnotationContent
      @   ensures [file at path].annotationContent == \old(&lt;[file at path]&gt;).annotationContent
     */
    public static DocumentCommandWrapper loadDosumentAtPath(String aPath) throws IOException {
<span class="nc" id="L128">        DocumentCommandWrapper result = null;</span>
<span class="nc" id="L129">        PDDocument document = PDDocument.load(new File(aPath));</span>

<span class="nc bnc" id="L131" title="All 2 branches missed.">        if (null != document) {</span>
<span class="nc" id="L132">            result = new DocumentCommandWrapper(document, aPath);</span>
        }

<span class="nc" id="L135">        return result;</span>
    }

    /**
     * Save the PDF information including annotations encapsulated by the
     * receiver to a file at the specified path. The saved information contains
     * the same annotation and non-annotation information as the file (if any)
     * from which information was loaded to initialize the receiver with the
     * following exceptions: - Annotations added via the receiver since
     * information was loaded are saved in the specified file. - Annotations
     * deleted via the receiver since information was loaded are not saved in
     * the specified file. - Annotations whose attributes have been changed via
     * the receiver since information was loaded are save with changed
     * attributes in the specified file. Trace: REQ-041000, REQ-041050
     *
     * @param aPath A valid complete file system path including the name of the
     * document to save. The path must be writable in a file system with
     * sufficient available storage capacity to store the information
     * encapsulated by the receiver.
     * @throws java.io.IOException
     */
    /*@   requires aPath is valid 
      @   assignable \nothing;
      @   [replaces any pre-existing file at aPath]
      @   ensures wrappedDocument.nonAnnotationContent == \old(&lt;wrappedDocument&gt;).nonAnnotationContent
      @   ensures wrappedDocument.annotationContent ==  \old(&lt;wrappedDocument&gt;).annotationContent
      @   ensures [file at path].nonAnnotationContent == wrappedDocument.nonAnnotationContent
      @   ensures [file at path].annotationContent == wrappedDocument.annotationContent
     */
    public void save(String aPath) throws IOException {
<span class="nc" id="L165">        wrappedDocument.save(aPath.substring(0, aPath.lastIndexOf('.')) + &quot;~.pdf&quot;);</span>
<span class="nc" id="L166">    }</span>

    /**
     * Instances of this class encapsulate commands to annotate PDF documents by
     * adding boxes. Boxes are rectangular regions of color on a page.
     */
<span class="nc bnc" id="L172" title="All 2 branches missed.">    public class AddBoxAnnotationDocumentCommand extends AbstractDocumentCommand {</span>

        /**
         *
         * @param anOwner
         * @param args
         */
<span class="nc" id="L179">        public AddBoxAnnotationDocumentCommand(AbstractDocumentCommandWrapper anOwner, ArrayList&lt;String&gt; args) {</span>
<span class="nc" id="L180">            super(anOwner, args);</span>
<span class="nc" id="L181">        }</span>

        /**
         *
         * @return If execute() succeeds, a Command that is the reciprocal of
         * the receiver is returned. Otherwise, null is returned.
         */
        @Override
        public AbstractDocumentCommand execute() {
<span class="nc" id="L190">            AbstractDocumentCommand result = null;</span>

<span class="nc bnc" id="L192" title="All 6 branches missed.">            assert null != arguments &amp;&amp; arguments.size() == 5;</span>
<span class="nc" id="L193">            List&lt;PDAnnotation&gt; previousAnnotations = BoxAnnotationMaker.make(owner.wrappedDocument, arguments);</span>
<span class="nc" id="L194">            result = new ReplaceAnnotationDocumentCommand(owner, previousAnnotations, arguments);</span>

<span class="nc" id="L196">            return result;</span>
        }

        /**
         *
         * @return The name of the command as it will appear in a user interface
         * for undo and redo operations e.g. &quot;Undo Delete Annotation&quot; where the
         * string after &quot;Undo &quot; is returned from getName().
         */
        @Override
        public String getName() {
<span class="nc" id="L207">            return &quot;Add Box Annotation&quot;;</span>
        }
    }

    /**
     * Instances of this class encapsulate commands to annotate PDF documents;
     * by adding an ellipse containing a text string. Ellipses are inscribed in
     * a rectangular regions of a page, and the text string is centered in the
     * ellipse.
     */
<span class="nc bnc" id="L217" title="All 2 branches missed.">    public class AddCircleAnnotationDocumentCommand extends AbstractDocumentCommand {</span>

        /**
         *
         * @param anOwner
         * @param args
         */
<span class="nc" id="L224">        public AddCircleAnnotationDocumentCommand(AbstractDocumentCommandWrapper anOwner, ArrayList&lt;String&gt; args) {</span>
<span class="nc" id="L225">            super(anOwner, args);</span>
<span class="nc" id="L226">        }</span>

        /**
         *
         * @return If execute() succeeds, a Command that is the reciprocal of
         * the receiver is returned. Otherwise, null is returned.
         */
        @Override
        public AbstractDocumentCommand execute() {
<span class="nc" id="L235">            AbstractDocumentCommand result = null;</span>

<span class="nc bnc" id="L237" title="All 6 branches missed.">            assert null != arguments &amp;&amp; arguments.size() == 6;</span>
<span class="nc" id="L238">            List&lt;PDAnnotation&gt; previousAnnotations = EllipseAnnotationMaker.make(owner.wrappedDocument, arguments);</span>
<span class="nc" id="L239">            result = new ReplaceAnnotationDocumentCommand(owner, previousAnnotations, arguments);</span>

<span class="nc" id="L241">            return result;</span>
        }

        /**
         *
         * @return The name of the command as it will appear in a user interface
         * for undo and redo operations e.g. &quot;Undo Delete Annotation&quot; where the
         * string after &quot;Undo &quot; is returned from getName().
         */
        @Override
        public String getName() {
<span class="nc" id="L252">            return &quot;Add Ellipse Annotation&quot;;</span>
        }
    }

    /**
     * Instances of this class encapsulate commands to annotate PDF documents by
     * adding text.
     */
<span class="nc bnc" id="L260" title="All 2 branches missed.">    public class AddTextAnnotationDocumentCommand extends AbstractDocumentCommand {</span>

        /**
         *
         * @param anOwner
         * @param args
         */
<span class="nc" id="L267">        public AddTextAnnotationDocumentCommand(AbstractDocumentCommandWrapper anOwner, ArrayList&lt;String&gt; args) {</span>
<span class="nc" id="L268">            super(anOwner, args);</span>
<span class="nc" id="L269">        }</span>

        /**
         *
         * @return If execute() succeeds, a Command that is the reciprocal of
         * the receiver is returned. Otherwise, null is returned.
         */
        @Override
        public AbstractDocumentCommand execute() {
<span class="nc" id="L278">            AbstractDocumentCommand result = null;</span>

<span class="nc bnc" id="L280" title="All 6 branches missed.">            assert null != arguments &amp;&amp; arguments.size() == 6;</span>
<span class="nc" id="L281">            List&lt;PDAnnotation&gt; previousAnnotations = TextAnnotationMaker.make(owner.wrappedDocument, arguments);</span>
<span class="nc" id="L282">            result = new ReplaceAnnotationDocumentCommand(owner, previousAnnotations, arguments);</span>

<span class="nc" id="L284">            return result;</span>
        }

        /**
         *
         * @return The name of the command as it will appear in a user interface
         * for undo and redo operations e.g. &quot;Undo Delete Annotation&quot; where the
         * string after &quot;Undo &quot; is returned from getName().
         */
        @Override
        public String getName() {
<span class="nc" id="L295">            return &quot;Add Text Annotation&quot;;</span>
        }
    }

    /**
     * Instances of this class encapsulate commands to annotate PDF documents
     * encapsulated by deleting an existing annotation.
     */
<span class="nc bnc" id="L303" title="All 2 branches missed.">    public class DeleteAnnotationDocumentCommand extends AbstractDocumentCommand {</span>

        /**
         *
         * @param anOwner
         * @param args
         */
<span class="nc" id="L310">        public DeleteAnnotationDocumentCommand(AbstractDocumentCommandWrapper anOwner, ArrayList&lt;String&gt; args) {</span>
<span class="nc" id="L311">            super(anOwner, args);</span>
<span class="nc" id="L312">        }</span>

        /**
         *
         * @return If execute() succeeds, a Command that is the reciprocal of
         * the receiver is returned. Otherwise, null is returned.
         */
        @Override
        public AbstractDocumentCommand execute() {
<span class="nc bnc" id="L321" title="All 4 branches missed.">            assert 3 == arguments.size();</span>

<span class="nc" id="L323">            AbstractDocumentCommand result = null;</span>

            // We have to find the annotation to delete
<span class="nc" id="L326">            int pageNumber = parseInt(arguments.get(0));</span>
<span class="nc" id="L327">            float x = parseFloat(arguments.get(1));</span>
<span class="nc" id="L328">            float y = parseFloat(arguments.get(2));</span>

<span class="nc" id="L330">            PDPage page = owner.wrappedDocument.getPage(pageNumber);</span>

            try {
<span class="nc" id="L333">                List&lt;PDAnnotation&gt; oldAnnotations = page.getAnnotations();</span>
<span class="nc" id="L334">                PDAnnotation victim = owner.getLastAnnotationAtPoint(oldAnnotations, x, y);</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">                if (null != victim) {</span>
<span class="nc" id="L336">                    result = new ReplaceAnnotationDocumentCommand(owner, new ArrayList&lt;&gt;(oldAnnotations), arguments);</span>
<span class="nc" id="L337">                    oldAnnotations.remove(victim);</span>
<span class="nc" id="L338">                    page.setAnnotations(oldAnnotations);</span>
                }
<span class="nc" id="L340">            } catch (IOException ex) {</span>
//                Logger.getLogger(DocumentCommandWrapper.class.getName()).log(Level.SEVERE, null, ex);
<span class="nc" id="L342">            }</span>

<span class="nc" id="L344">            return result;</span>
        }

        /**
         *
         * @return The name of the command as it will appear in a user interface
         * for undo and redo operations e.g. &quot;Undo Delete Annotation&quot; where the
         * string after &quot;Undo &quot; is returned from getName().
         */
        @Override
        public String getName() {
<span class="nc" id="L355">            return &quot;Delete Annotation&quot;;</span>
        }
    }

    /**
     *
     */
<span class="nc bnc" id="L362" title="All 2 branches missed.">    public class MoveAnnotationDocumentCommand extends AbstractDocumentCommand {</span>

        /**
         *
         * @param anOwner
         * @param args
         */
<span class="nc" id="L369">        public MoveAnnotationDocumentCommand(AbstractDocumentCommandWrapper anOwner, ArrayList&lt;String&gt; args) {</span>
<span class="nc" id="L370">            super(anOwner, args);</span>
<span class="nc bnc" id="L371" title="All 4 branches missed.">            assert 5 == args.size();</span>
<span class="nc" id="L372">        }</span>

        /**
         *
         * @param anOwner
         * @param annotations
         * @param args
         */
<span class="nc" id="L380">        public MoveAnnotationDocumentCommand(AbstractDocumentCommandWrapper anOwner, List&lt;PDAnnotation&gt; annotations, ArrayList&lt;String&gt; args) {</span>
<span class="nc" id="L381">            super(anOwner, annotations, args);</span>
<span class="nc bnc" id="L382" title="All 4 branches missed.">            assert 1 == annotations.size();</span>
<span class="nc bnc" id="L383" title="All 4 branches missed.">            assert 5 == args.size();</span>
<span class="nc" id="L384">        }</span>

        /**
         *
         * @return If execute() succeeds, a Command that is the reciprocal of
         * the receiver is returned. Otherwise, null is returned.
         */
        @Override
        public AbstractDocumentCommand execute() {
<span class="nc" id="L393">            AbstractDocumentCommand result = null;</span>
<span class="nc" id="L394">            PDAnnotation candidate = null;</span>

<span class="nc bnc" id="L396" title="All 4 branches missed.">            assert 5 == arguments.size();</span>

<span class="nc" id="L398">            int pageNumber = parseInt(arguments.get(0));</span>
<span class="nc" id="L399">            float x = parseFloat(arguments.get(1));</span>
<span class="nc" id="L400">            float y = parseFloat(arguments.get(2));</span>
<span class="nc" id="L401">            float dx = parseFloat(arguments.get(3));</span>
<span class="nc" id="L402">            float dy = parseFloat(arguments.get(4));</span>

<span class="nc bnc" id="L404" title="All 4 branches missed.">            if (null == annotations || 0 == annotations.size()) {</span>
                try {
                    // We have to find the annotation to move
<span class="nc" id="L407">                    PDPage page = owner.wrappedDocument.getPage(pageNumber);</span>
<span class="nc" id="L408">                    List&lt;PDAnnotation&gt; oldAnnotations = page.getAnnotations();</span>
<span class="nc" id="L409">                    candidate = owner.getLastAnnotationAtPoint(oldAnnotations, x, y);</span>
<span class="nc" id="L410">                } catch (IOException ex) {</span>
//                    Logger.getLogger(DocumentCommandWrapper.class.getName()).log(Level.SEVERE, null, ex);
<span class="nc" id="L412">                }</span>
            } else {
                // We can just delete annotation
<span class="nc" id="L415">                candidate = annotations.get(0);</span>
            }

<span class="nc bnc" id="L418" title="All 2 branches missed.">            if (null != candidate) {</span>

<span class="nc" id="L420">                ArrayList&lt;String&gt; newArgs = new ArrayList&lt;&gt;(arguments);</span>
<span class="nc" id="L421">                newArgs.set(3, Float.toString(-dx));</span>
<span class="nc" id="L422">                newArgs.set(4, Float.toString(-dy));</span>
<span class="nc" id="L423">                ArrayList&lt;PDAnnotation&gt; candidateList = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L424">                candidateList.add(candidate);</span>
<span class="nc" id="L425">                result = new MoveAnnotationDocumentCommand(owner, candidateList, newArgs);</span>

<span class="nc" id="L427">                PDRectangle position = candidate.getRectangle();</span>
<span class="nc" id="L428">                position.setLowerLeftX(position.getLowerLeftX() + dx);</span>
<span class="nc" id="L429">                position.setLowerLeftY(position.getLowerLeftY() + dy);</span>
<span class="nc" id="L430">                position.setUpperRightX(position.getUpperRightX() + dx);</span>
<span class="nc" id="L431">                position.setUpperRightY(position.getUpperRightY() + dy);</span>
<span class="nc" id="L432">                candidate.setRectangle(position);</span>
            }

<span class="nc" id="L435">            return result;</span>
        }

        /**
         *
         * @return The name of the command as it will appear in a user interface
         * for undo and redo operations e.g. &quot;Undo Delete Annotation&quot; where the
         * string after &quot;Undo &quot; is returned from getName().
         */
        @Override
        public String getName() {
<span class="nc" id="L446">            return &quot;Move Annotation&quot;;</span>
        }

    }

    /**
     *
     */
<span class="nc bnc" id="L454" title="All 2 branches missed.">    public class ReplaceAnnotationDocumentCommand extends AbstractDocumentCommand {</span>

        /**
         *
         * @param anOwner
         * @param someAnnotations
         * @param args
         */
<span class="nc" id="L462">        protected ReplaceAnnotationDocumentCommand(AbstractDocumentCommandWrapper anOwner, List&lt;PDAnnotation&gt; someAnnotations, ArrayList&lt;String&gt; args) {</span>
<span class="nc" id="L463">            super(anOwner, someAnnotations, args);</span>
<span class="nc" id="L464">        }</span>

        /**
         *
         * @return If execute() succeeds, a Command that is the reciprocal of
         * the receiver is returned. Otherwise, null is returned.
         */
        @Override
        public AbstractDocumentCommand execute() {
<span class="nc bnc" id="L473" title="All 6 branches missed.">            assert null != annotations &amp;&amp; 1 == annotations.size();</span>
<span class="nc bnc" id="L474" title="All 6 branches missed.">            assert null != arguments &amp;&amp; 0 &lt; arguments.size();</span>

<span class="nc" id="L476">            AbstractDocumentCommand result = null;</span>
            try {
<span class="nc" id="L478">                int pageNumber = parseInt(arguments.get(0));</span>

<span class="nc" id="L480">                PDPage page = owner.wrappedDocument.getPage(pageNumber);</span>
<span class="nc" id="L481">                result = new ReplaceAnnotationDocumentCommand(owner, new ArrayList&lt;PDAnnotation&gt;(page.getAnnotations()), arguments);</span>
<span class="nc" id="L482">                page.setAnnotations(annotations);</span>

<span class="nc" id="L484">            } catch (IOException ex) {</span>
//                Logger.getLogger(DocumentCommandWrapper.class.getName()).log(Level.SEVERE, null, ex);
<span class="nc" id="L486">            }</span>

<span class="nc" id="L488">            return result;</span>
        }

        /**
         *
         * @return The name of the command as it will appear in a user interface
         * for undo and redo operations e.g. &quot;Undo Delete Annotation&quot; where the
         * string after &quot;Undo &quot; is returned from getName().
         */
        @Override
        public String getName() {
<span class="nc" id="L499">            return &quot;Undelete Annotation&quot;;</span>
        }

    }

    /**
     *
     */
<span class="nc bnc" id="L507" title="All 2 branches missed.">    public class SaveDocumentCommand extends AbstractDocumentCommand {</span>

        /**
         *
         * @param anOwner
         * @param args
         */
<span class="nc" id="L514">        protected SaveDocumentCommand(AbstractDocumentCommandWrapper anOwner, ArrayList&lt;String&gt; args) {</span>
<span class="nc" id="L515">            super(anOwner, args);</span>
<span class="nc bnc" id="L516" title="All 4 branches missed.">            assert 1 == args.size();</span>
<span class="nc" id="L517">        }</span>

        /**
         *
         * @return If execute() succeeds, a Command that is the reciprocal of
         * the receiver is returned. Otherwise, null is returned.
         */
        @Override
        public AbstractDocumentCommand execute() {
<span class="nc bnc" id="L526" title="All 6 branches missed.">            assert null != arguments &amp;&amp; 1 == arguments.size();</span>

            try {
<span class="nc" id="L529">                owner.wrappedDocument.save(arguments.get(0));</span>
<span class="nc" id="L530">            } catch (IOException ex) {</span>
//                Logger.getLogger(DocumentCommandWrapper.class.getName()).log(Level.SEVERE, null, ex);
<span class="nc" id="L532">            }</span>

<span class="nc" id="L534">            return null; // Prevent &quot;Save&quot; item on undo stack</span>
        }

        /**
         *
         * @return The name of the command as it will appear in a user interface
         * for undo and redo operations e.g. &quot;Undo Delete Annotation&quot; where the
         * string after &quot;Undo &quot; is returned from getName().
         */
        @Override
        public String getName() {
<span class="nc" id="L545">            return &quot;Save Annotations and Non-annotations&quot;;</span>
        }

    }

    /**
     *
     */
<span class="nc bnc" id="L553" title="All 2 branches missed.">    public class SaveTextDocumentCommand extends AbstractDocumentCommand {</span>

        /**
         *
         * @param anOwner
         * @param args
         */
<span class="nc" id="L560">        protected SaveTextDocumentCommand(AbstractDocumentCommandWrapper anOwner, ArrayList&lt;String&gt; args) {</span>
<span class="nc" id="L561">            super(anOwner, args);</span>
<span class="nc bnc" id="L562" title="All 4 branches missed.">            assert 1 == args.size();</span>
<span class="nc" id="L563">        }</span>

        /**
         *
         * @return If execute() succeeds, a Command that is the reciprocal of
         * the receiver is returned. Otherwise, null is returned.
         */
        @Override
        public AbstractDocumentCommand execute() {
<span class="nc bnc" id="L572" title="All 6 branches missed.">            assert null != arguments &amp;&amp; 1 == arguments.size();</span>

            try {
<span class="nc" id="L575">                PDFTextStripper stripper = new PDFTextStripper();</span>
<span class="nc" id="L576">                String parsedText = stripper.getText(owner.wrappedDocument);</span>
<span class="nc" id="L577">                Files.write(Paths.get(arguments.get(0)), parsedText.getBytes(), StandardOpenOption.CREATE);</span>
<span class="nc" id="L578">            } catch (IOException ex) {</span>
//                Logger.getLogger(DocumentCommandWrapper.class.getName()).log(Level.SEVERE, null, ex);
<span class="nc" id="L580">            }</span>

<span class="nc" id="L582">            return null; // Prevent &quot;Save&quot; item on undo stack</span>
        }

        /**
         *
         * @return The name of the command as it will appear in a user interface
         * for undo and redo operations e.g. &quot;Undo Delete Annotation&quot; where the
         * string after &quot;Undo &quot; is returned from getName().
         */
        @Override
        public String getName() {
<span class="nc" id="L593">            return &quot;Save Non-annotation Text&quot;;</span>
        }

    }

    /**
     * Instances of this class encapsulate commands to annotate PDF documents
     * encapsulated by deleting an existing annotation.
     */
<span class="nc bnc" id="L602" title="All 2 branches missed.">    public class DeleteSelectedAnnotationDocumentCommand extends AbstractDocumentCommand {</span>

        /**
         *
         * @param anOwner
         * @param someAnnotations
         */
<span class="nc" id="L609">        public DeleteSelectedAnnotationDocumentCommand(AbstractDocumentCommandWrapper anOwner, ArrayList&lt;String&gt; args) {</span>
<span class="nc" id="L610">            super(anOwner, args);</span>
<span class="nc" id="L611">        }</span>

        /**
         *
         * @return If execute() succeeds, a Command that is the reciprocal of
         * the receiver is returned. Otherwise, null is returned.
         */
        @Override
        public AbstractDocumentCommand execute() {
<span class="nc bnc" id="L620" title="All 4 branches missed.">            assert 0 &lt; arguments.size();</span>

<span class="nc" id="L622">            int pageNumber = parseInt(arguments.get(0));</span>
            List&lt;PDAnnotation&gt; oldAnnotations;
<span class="nc" id="L624">            List&lt;PDAnnotation&gt; selectedAnnotations = owner.getSelectedAnnotations();</span>
<span class="nc" id="L625">            AbstractDocumentCommand result = null;</span>

<span class="nc bnc" id="L627" title="All 2 branches missed.">            if (0 &lt; selectedAnnotations.size()) {</span>
                try {
<span class="nc" id="L629">                    PDPage page = owner.wrappedDocument.getPage(pageNumber);</span>
<span class="nc" id="L630">                    oldAnnotations = page.getAnnotations();</span>
<span class="nc" id="L631">                    result = new ReplaceAnnotationDocumentCommand(owner, new ArrayList&lt;&gt;(oldAnnotations), arguments);</span>
<span class="nc bnc" id="L632" title="All 2 branches missed.">                    for (PDAnnotation a : selectedAnnotations) {</span>
<span class="nc" id="L633">                        List&lt;PDAnnotation&gt; itemsToRemove = oldAnnotations.stream().filter(</span>
<span class="nc" id="L634">                                p -&gt; p.getAnnotationName().equals(a.getAnnotationName())).collect(Collectors.toCollection(ArrayList::new));</span>

<span class="nc bnc" id="L636" title="All 2 branches missed.">                        if (null != itemsToRemove) {</span>
<span class="nc bnc" id="L637" title="All 2 branches missed.">                            for (PDAnnotation pa : itemsToRemove) {</span>
<span class="nc" id="L638">                                oldAnnotations.remove(pa);</span>
<span class="nc" id="L639">                            }</span>
                        }
<span class="nc" id="L641">                    }</span>
<span class="nc" id="L642">                    page.setAnnotations(oldAnnotations);</span>
<span class="nc" id="L643">                    owner.deselectAll();</span>
<span class="nc" id="L644">                } catch (IOException ex) {</span>
//                    Logger.getLogger(DocumentCommandWrapper.class.getName()).log(Level.SEVERE, null, ex);
<span class="nc" id="L646">                }</span>

            }

<span class="nc" id="L650">            return result;</span>
        }

        /**
         *
         * @return The name of the command as it will appear in a user interface
         * for undo and redo operations e.g. &quot;Undo Delete Annotation&quot; where the
         * string after &quot;Undo &quot; is returned from getName().
         */
        @Override
        public String getName() {
<span class="nc" id="L661">            return &quot;Delete Annotation&quot;;</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>